---
title: "Quality Control: Filtering & Trimming Amplicon Sequences"
output: html_document
date: "2025-03-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.align = "center",
                      fig.path = "../figures/01_DADA2")
```

#set the seed
```{r set-seed}
set.seed(20020718)

```

#timing of script
```{r rmd-start}
# What time did we start running this script? 
start_time <- Sys.time()
start_time

```

#load libraries
```{r load-libraries}
# Efficient package loading with pacman 
# Don't forget to install pacman and DT if you don't have it yet. :) 
pacman::p_load(tidyverse, dada2, phyloseq, patchwork, DT, devtools, install = FALSE)

```

#reading raw sequencing files
```{r load-data}
# Set the raw fastq path to the raw sequencing files 
# Path to the fastq files 
raw_fastqs_path <- "data/01_DADA2/01_raw_gzipped_fastqs"
raw_fastqs_path

# What files are in this path? Intuition Check 
head(list.files(raw_fastqs_path))

# How many files are there? 
length(list.files(raw_fastqs_path))

# Create vector of forward reads
forward_reads <- list.files(raw_fastqs_path, pattern = "1.fastq.gz", full.names = TRUE)  

# Intuition Checks 
head(forward_reads)
# Intuition check #2: We should have fewer reads in the forward vector than in total 
stopifnot(length(forward_reads) < length(list.files(raw_fastqs_path)))

# Create a vector of reverse reads 
reverse_reads <- list.files(raw_fastqs_path, pattern = "2.fastq.gz", full.names = TRUE)

# Intuition Checks
head(reverse_reads)
# Intuition check #2: Need to have equal number of forward and reverse files 
stopifnot(length(reverse_reads) == length(forward_reads))

```


# Assess Raw Read Quality 

## Evaluate raw sequence quality 

Let's see the quality of the raw reads *before* we trim

## Plot 12 random samples of plots 

```{r raw-quality-plot, fig.width=12, fig.height=8}
# Randomly select 12 samples from dataset to evaluate 
# Selecting 12 is typically better than 2 (like we did in class for efficiency)
random_samples <- sample(1:length(reverse_reads), size = 12)
random_samples

# Calculate and plot quality of these two samples
forward_filteredQual_plot_12 <- plotQualityProfile(forward_reads[random_samples]) + 
  labs(title = "Forward Read: Raw Quality")+
  guides(scale = "none")

forward_filteredQual_plot_12

reverse_filteredQual_plot_12 <- plotQualityProfile(reverse_reads[random_samples]) + 
  labs(title = "Reverse Read: Raw Quality")+
  guides(scale = "none")

# Plot them together with patchwork
forward_filteredQual_plot_12 + reverse_filteredQual_plot_12
```

## Aggregated Raw Quality Plots 

Next, we will plot all of the samples aggregated into one forward (left) and one reverse read (right) plot. 

```{r raw-aggregate-plot, fig.width=5.5, fig.height=3.5}
# Aggregate all QC plots 
# Forward reads
forward_preQC_plot <- 
  plotQualityProfile(forward_reads, aggregate = TRUE) + 
  labs(title = "Forward Pre-QC")+
  guides(scale = "none")

# reverse reads
reverse_preQC_plot <- 
  plotQualityProfile(reverse_reads, aggregate = TRUE) + 
  labs(title = "Reverse Pre-QC")+
  guides(scale = "none")

# Now, let's put the two plots together
preQC_aggregate_plot <- 
  # Plot the forward and reverse together 
  forward_preQC_plot + reverse_preQC_plot
# Show the plot
preQC_aggregate_plot

```

<span style="color: red;">INTERPRETATION #1 of Pre-QC: Here, in this location of your analyses, please insert a description of the interpretation you draw regarding your plots. You must note anything important about the figure you've created about your data including any spikes in quality and also the general trend of the raw QC plots. An example is provided below.</span> 

Above are plots showing the pre-QC quality scores of the raw sequencing data for the project. We can draw a few conclusions from the plots above, which were generated with Illumina MiSeq v3 chemistry with 300-bp paired end: 

1.	*Early Bases have a drop in quality (~Cycle/Bases 0-10):* 
    - The initial bases of both forward and reverse reads have low quality scores that drop to around or below 30.
    - This is okay because primers are included in the beginning of the sequences and will be later on removed.
2.	*Higher Quality in first half of Mid-Read (~10-150 Cycles/Bases):* 
    - The first half of reads are relatively higher quality, mostly being above 25.
3.	*Decline in quality in the second half of read (150-300 cycles/bases:*
    - For both forward and reverse reads, the quality score quickly declines starting in the middle, with forward reads dropping to below 25 and reverse reads dropping to below 20.
    - At the very end of reads, quality scores drop to 10, which is extremely poor.
    - **Solution**: We will truncate the read using ` truncLen = 230` to remove the last 70 base pairs of every read to keep quality scores at least above 20
4.	*some reads have very poor quality score throughout*
    - From the random 12 samples, a couple have quality score below 10 throughout the base positions. These should be removed with trunQ.


#prepare a placeholder for filtered reads
```{r prep-filtered-sequences}
# Create vector of sample names from the filenames 
sample_names <- sapply(strsplit(basename(forward_reads), "_"), `[`,1) 

# Intuition Check 
head(sample_names)

# Place filtered reads into filtered_fastqs_path
filtered_fastqs_path <- "data/01_DADA2/02_filtered_fastqs"

# Intuition Check 
filtered_fastqs_path

# create 2 vectors: filtered_forward_reads & filtered_reverse_reads
filtered_forward_reads <- 
  file.path(filtered_fastqs_path, paste0(sample_names, "_R1_filtered.fastq.gz"))

# Intuition Check 
length(filtered_forward_reads)

# reverse reads
filtered_reverse_reads <- 
  file.path(filtered_fastqs_path, paste0(sample_names, "_R2_filtered.fastq.gz"))

# Intuition Check 
head(filtered_reverse_reads)

```

#filter and trim
```{r filter-and-trim}
filtered_reads <- 
  filterAndTrim(forward_reads, filtered_forward_reads,
             reverse_reads, filtered_reverse_reads,
              truncLen = c(290,280), trimLeft = c(19,22),
              maxN = 0, maxEE = c(1,1), truncQ = 2, 
              rm.phix = TRUE, compress = TRUE, 
              multithread = 10)

```

#assess trimming quality
```{r filterTrim-quality-plots,  fig.width=12, fig.height=8}
# Plot the 12 random samples after QC
forward_filteredQual_plot_12 <- 
  plotQualityProfile(filtered_forward_reads[random_samples]) + 
  labs(title = "Trimmed Forward Read Quality")+
  guides(scale = "none")

reverse_filteredQual_plot_12 <- 
  plotQualityProfile(filtered_reverse_reads[random_samples]) + 
  labs(title = "Trimmed Reverse Read Quality")+
  guides(scale = "none")

# Put the two plots together 
forward_filteredQual_plot_12 + reverse_filteredQual_plot_12
```

## Aggregated Trimmed Plots 
```{r qc-aggregate-plot, fig.width=5.5, fig.height=3.5}
# Aggregate all QC plots 
# Forward reads
forward_postQC_plot <- 
  plotQualityProfile(filtered_forward_reads, aggregate = TRUE) + 
  labs(title = "Forward Post-QC")+
  guides(scale = "none")

# reverse reads
reverse_postQC_plot <- 
  plotQualityProfile(filtered_reverse_reads, aggregate = TRUE) + 
  labs(title = "Reverse Post-QC")+
  guides(scale = "none")

# Now, let's put the two plots together
postQC_aggregate_plot <- 
  # Plot the forward and reverse together 
  forward_postQC_plot + reverse_postQC_plot
# Show the plot
postQC_aggregate_plot

```


## Read Retention Post-QC
```{r filterTrim-stats, message = FALSE, fig.height = 2.5, fig.width=8}
# Make output into dataframe 
filtered_df <- as.data.frame(filtered_reads) %>%
  mutate(percent.retained = reads.out/reads.in)

# Intuition check
# Visualize it in table format 
DT::datatable(filtered_df)

# Let's calculate some statistics
read_stats_df <- 
  filtered_df %>%
  reframe(median_reads_in = median(reads.in),
          median_reads_out = median(reads.out),
          median_percent_retained = (median(reads.out)/median(reads.in)),
          max_percent_retained = max(reads.out/reads.in),
          min_percent_retained = min(reads.out/reads.in))

# Take a look at it!
read_stats_df

# Plot it 
numSeqs_QC_dotplot <-
  filtered_df %>%
  ggplot(aes(x = reads.in, y = reads.out)) + 
  geom_point(alpha = 0.5, size = 2) + 
  labs(x = "# of Raw Seqs", 
       y = "# of Seqs Retained") + 
  # Now let's add a 1:1 line for reference of keeping 100% of the reads
  geom_abline(slope=1, intercept = 0, color = "deeppink")

# Now, let's look at the number of reads retained in a histogram
numRetained_QC_histplot <- 
  filtered_df %>%
  ggplot(aes(x = reads.out)) + 
  geom_histogram() + 
  labs(x = "# of Seqs Retained", 
       y = "# of Samples") 

# Create a histogram of percent reads retained in a histogram
percSeqs_QC_histplot <- 
  filtered_df %>%
  ggplot(aes(x = percent.retained)) + 
  geom_histogram() + 
  labs(x = "% of Seqs Retained", 
       y = "# of Samples") + 
  # Set the scale to be between 0-1 (0-100%)
  scale_x_continuous(limits = c(0, 1))

# Now, let's put the plots together
numSeqs_QC_dotplot + numRetained_QC_histplot + percSeqs_QC_histplot + 
  plot_annotation(tag_levels = 'A')

```


<span style="color: red;">INTERPRETATION #3 of Post-QC Statistics: Here, in this location of your analyses, please insert a description of the interpretation you draw regarding your read retainment pre- and post-QC. Please note anything important about the three paneled figure you created above. Think about how many reads got through? Is it "enough"? Should I play with the parameters in `filterAndTrim()` more?  If so, which parameters? An example interpretation is provided below. </span> 

This figure presents three panels showing how many sequences were retained after quality filtering and trimming in the DADA2 pipeline. Letâ€™s break down each panel:

**Panel A: Scatter Plot of Raw vs. Retained Sequences:**  

- X-axis: Number of raw sequences before filtering.
- Y-axis: Number of sequences retained after filtering.
- Pink Line: The diagonal line represents perfect retention (i.e., no sequences lost).

*Interpretation of Panel A:*  

- The points are a bit distant from the diagonals, meaning that many reads were lost.
- However, they are still clustered together in two lines with few outliers. The line farther from the pink line may belong to the reverse reads with lower quality
- samples with more sequences also have more sequences lost, which is expected.

**Panel B: Histogram of the Number of Sequences Retained per Sample**  

- X-axis: Number of sequences retained per sample.
- Y-axis: Number of samples with that many retained sequences.

*Interpretation of Panel B*  
- The majority of samples have between ~5,000 and 10,000 retained sequences, which suggests good filtering efficiency.
- Around 9 samples retained no reads and will need to be removed. This is expected as from the quality plots of 12 random samples, some samples have a very poor quality score throughout.


**Panel C: Histogram of Percent of Sequences Retained**  

- X-axis: Proportion (%) of sequences retained per sample.
- Y-axis: Number of samples at each proportion.

*Interpretation of Panel C*. 

- Most samples retained ~70% of their sequences, which is a bit low.
- However, quality scores of the reads are relatively low and we do not want to keep low quality reads in samples.
- Some sample lost over 50% of the reads and we will keep on eye on them.
- **Max % Retained** is `r read_stats_df$max_percent_retained` is fantastic while **min % retained is** `r read_stats_df$min_percent_retained` alarming.
- A **median % retained ** of `r read_stats_df$median_percent_retained` is acceptable! 


**Consider re-running your `filterAndTrim()` if:** 

- If important samples lost too many reads, consider relaxing `maxEE` (expected errors) or adjusting truncation lengths (`truncLen`).
- Low merging success later on in the DADA2 workflow (suggests too much length variation).
- Reverse read degradation still affects error modeling (trim further if needed).

### Visualize QC differences in plot
```{r pre-post-QC-plot, fig.width=6, fig.height=5.5}
# Plot the pre and post together in one plot
preQC_aggregate_plot / postQC_aggregate_plot

```

<span style="color: red;">INTERPRETATION #4 is comparing your pre-QC to your post-QC read quality. Here, in this location of your analyses, please insert a description of the interpretation you draw from yor overall quality control results. Are you satisfied with your QC process? An example interpretation is provided below. </span> 

**Quality Score Improvements**

- *Forward Reads (Pre vs. Post-QC)*
  - *Beginning of read*: The lower quality reads at the beginning are now completely removed. All reads now start at above 35 score.
  - *Middle of read*: The quality is now consistently high with Q35-Q40 across all cycles/bases.
  - *End of read*: The quality of reads remains strong at the end, with scores above 30.
- *Reverse Reads (Pre vs. Post-QC)*
  - *Beginning of read*: The lower quality reads at the beginning are not completely removed. All reads now start at above 35 score.
  - *Middle of read*: The quality is now consistently high with Q35-Q40 across all cycles/bases.
  - *End of read*:" The very end of the reverse reads still experience a drop in quality. However, reverse reads are expected to of lower quality than forward reads. Significant improvements can be seen from the pre-QC plots where the scores drop below 20. 

# Done with Analyses for now! :) 

# Check Render Time
```{r stop-time}
# Take the time now that we are at the end of the script
end_time <- Sys.time()
end_time 

# Echo the elapsed time
elapsed_time <- round((end_time - start_time), 3)
elapsed_time

```

#session information
```{r session-info}
# Ensure reproducibility 
devtools::session_info()
```

